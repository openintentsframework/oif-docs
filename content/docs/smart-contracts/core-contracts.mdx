---
title: Core Contracts
description: Deep dive into OIF smart contract implementations
---

# Core Contracts

This guide provides detailed information about OIF's core smart contract implementations.

## InputSettler Contracts

InputSettler contracts are deployed on the input (source) chain and manage the locking and release of input assets.

### InputSettlerCompact

Gas-efficient implementation using Resource Locks (ERC-7683 Compact).

**Location**: `src/input/compact/InputSettlerCompact.sol`

**Key Features:**

- Uses Permit2 for gasless approvals
- Resource Locks instead of traditional escrow
- Minimal gas overhead for settlement
- Supports compact encoding for cross-chain data

**When to Use:**

- High-volume applications requiring gas efficiency
- Integrations with Permit2-compatible systems
- Applications prioritizing transaction cost minimization

**Interface:**

```solidity
interface IInputSettlerCompact {
    function submitIntent(
        CompactIntent calldata intent
    ) external returns (bytes32 intentHash);

    function validateAndClaim(
        bytes32 intentHash,
        bytes calldata proof
    ) external;

    function cancelIntent(bytes32 intentHash) external;
}
```

### InputSettlerEscrow

Traditional escrow-based implementation with straightforward token locking.

**Location**: `src/input/escrow/InputSettlerEscrow.sol`

**Key Features:**

- Standard ERC-20 token transfers
- Explicit escrow locking and unlocking
- Simple integration path
- Compatible with any ERC-20 token

**When to Use:**

- Simple integration requirements
- Standard ERC-20 workflows

**Interface:**

```solidity
interface IInputSettlerEscrow {
    // Opens an intent; collects inputs from msg.sender into escrow.
    function open(
        StandardOrder calldata order
    ) external;

    // Opens an intent on behalf of `sponsor`; collects inputs via transferFrom, Permit2, or ERC-3009.
    function openFor(
        StandardOrder calldata order,
        address sponsor,
        bytes calldata signature
    ) external;

    // Finalises a filled order; sends escrowed inputs to `destination` and optionally calls back.
    function finalise(
        StandardOrder calldata order,
        InputSettlerBase.SolveParams[] calldata solveParams,
        bytes32 destination,
        bytes calldata call
    ) external;

    // Finalises using an order-owner signature authorizing the external claimant.
    function finaliseWithSignature(
        StandardOrder calldata order,
        InputSettlerBase.SolveParams[] calldata solveParams,
        bytes32 destination,
        bytes calldata call,
        bytes calldata orderOwnerSignature
    ) external;

    // Deterministic order identifier for the given order struct.
    function orderIdentifier(
        StandardOrder memory order
    ) external view returns (bytes32);

    // Purchase an order from the current solver within the allowed purchase window.
    function purchaseOrder(
        OrderPurchase memory orderPurchase,
        StandardOrder memory order,
        bytes32 orderSolvedByIdentifier,
        bytes32 purchaser,
        uint256 expiryTimestamp,
        bytes memory solverSignature
    ) external;
}
```

### InputSettlerPurchase

Optional extension for order purchasing/underwriting functionality.

**Location**: `src/input/InputSettlerPurchase.sol`

**Key Features:**

- Order purchase/underwriting: Third parties can buy an order from the solver and become the new owner.
- Discounted payment: Purchaser pays each input’s allocated amount minus a discount to `orderPurchase.destination`.
- `EIP-712` authorization: Requires a valid solver signature over `OrderPurchase`.
- Reentry protection and timing: Purchase window via timeToBuy, expiry guard, and write-then-call reentry pattern.
- Callback integration: Optional `IInputCallback.orderFinalised(inputs, callData)` after purchase.

**Purpose:**

- Solver capital rotation: Solvers can offload ownership for a discounted upfront payment.
- Operational UX: Purchasers can front capital to the destination quickly; solver offloads risk.

**Usage:**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {InputSettlerPurchase} from "./InputSettlerPurchase.sol";
import {LibAddress} from "../libs/LibAddress.sol";
import {OrderPurchase} from "./types/OrderPurchaseType.sol";

contract CustomInputSettler is InputSettlerPurchase {
    function purchaseOrder(
        OrderPurchase calldata orderPurchase,
        uint256[2][] calldata inputs,                  // [tokenId, allocatedAmount] per input
        bytes32 orderSolvedByIdentifier,               // solver identifier of the order being purchased
        uint256 expiryTimestamp,                       // anti-stale guard for the tx
        bytes calldata solverSignature                 // EIP-712 signature by the solver
    ) external {
        bytes32 purchaser = LibAddress.toIdentifier(msg.sender);
        _purchaseOrder(
            orderPurchase,
            inputs,
            orderSolvedByIdentifier,
            purchaser,
            expiryTimestamp,
            solverSignature
        );
    }
}
```

## OutputSettler Contracts

OutputSettler contracts are deployed on the output (destination) chain and handle solver fills.

### OutputSettlerBase

Abstract base that settles outputs on the destination chain for both native and ERC20 tokens. Also serves as an attester for oracle verification. Concrete contracts must implement `\_resolveOutput(...)`.

Main implementation for accepting and validating output fills.

**Location**: `src/output/OutputSettlerBase.sol`

**Key Features:**

- Settlement: Transfers ERC20 via safeTransferFrom or native via Address.sendValue
- Two fill modes:
  - Idempotent single fill: `fill(...)`
  - Atomic batch fill with competition semantics: `fillOrderOutputs(...)`
- Ownership semantics: First output’s solver “wins” the order in batch `fill`
- Callbacks: Optional `IOutputCallback.outputFilled(...)`
- Attestations: Records and validates fill attestations
- Safety: Fill deadline checks; payload size checks; re-entrancy protected via storage-first write

**Core Functions:**

```solidity
interface IOutputSettlerBase {
    function getFillRecord(
        bytes32 orderId,
        bytes32 outputHash
    ) external view returns (bytes32 payloadHash);

    function getFillRecord(
        bytes32 orderId,
        MandateOutput calldata output
    ) external view returns (bytes32 payloadHash);

    function fill(
        bytes32 orderId,
        MandateOutput calldata output,
        uint48 fillDeadline,
        bytes calldata fillerData
    ) external payable returns (bytes32 fillRecordHash);

    function fillOrderOutputs(
        bytes32 orderId,
        MandateOutput[] calldata outputs,
        uint48 fillDeadline,
        bytes calldata fillerData
    ) external payable;

    function hasAttested(
        bytes[] calldata payloads
    ) external view returns (bool accumulator);

    function setAttestation(
        bytes32 orderId,
        bytes32 solver,
        uint32 timestamp,
        MandateOutput calldata output
    ) external;
}
```

**Output Structure:**

```solidity
struct MandateOutput {
    /// @dev Oracle implementation responsible for collecting the proof from settler on output chain.
    bytes32 oracle;
    /// @dev Output Settler on the output chain responsible for settling the output payment.
    bytes32 settler;
    uint256 chainId;
    bytes32 token;
    uint256 amount;
    bytes32 recipient;
    /// @dev Data that will be delivered to recipient through the settlement callback on the output chain. Can be used
    /// to schedule additional actions.
    bytes callbackData;
    /// @dev Additional output context for the output settlement, encoding order types or other information.
    bytes context;
}
```

### Output Fill Process

1. **Solver Approval**: Solver approves OutputSettler to spend tokens
2. **Fill Submission**: Solver calls `fill()` with intent details
3. **Token Transfer**: OutputSettler transfers tokens to recipient
4. **Attestation**: OutputSettler marks payload as attested
5. **Callback** (optional): Execute callback on recipient contract

## Oracle Contracts

Oracle contracts provide the proof layer connecting input and output chains.

### BaseInputOracle

Base implementation providing standardized attestation storage.

**Location**: `src/oracles/BaseInputOracle.sol`

**Key Features:**

- Standardized attestation storage structure
- Efficient lookup via `hasAttested()`
- Compatible with all InputSettler implementations
- Extensible for different messaging protocols

**Interface:**

```solidity
interface IBaseInputOracle {
   // Public/external API
    function isProven(
        uint256 remoteChainId,
        bytes32 remoteOracle,
        bytes32 application,
        bytes32 dataHash
    ) external view returns (bool);

    function efficientRequireProven(
        bytes calldata proofSeries
    ) external view;

    // Internal utility
    function _isProven(
        uint256 remoteChainId,
        bytes32 remoteOracle,
        bytes32 application,
        bytes32 dataHash
    ) internal view virtual returns (bool);
}
```

## Oracle Integrations

OIF supports multiple oracle types under `src/integrations/oracles/`.

### Wormhole Oracle

Location: `src/integrations/oracles/wormhole/WormholeOracle.sol`

Cross-chain messaging via Wormhole VAAs.

- **Features**
  - Guardian-verified VAAs
  - Fast finality, broad chain coverage
  - Immutable chain ID mapping via `ChainMap` to translate Wormhole IDs
  - Transparent attestations for received payload hashes

- **Key methods**
  - `submit(address source, bytes[] payloads) payable`: Publishes message via Wormhole; refunds any excess ETH vs `messageFee()`.
  - `receiveMessage(bytes vaa)`: Verifies VAA and records `OutputProven` for each payload hash.

- **Configuration**
  - Provide Wormhole core contract address in constructor.
  - Set one-time chain ID mappings to canonical IDs.

---

### Hyperlane Oracle

Location: `src/integrations/oracles/hyperlane/HyperlaneOracle.sol`

Omnichain messaging via Hyperlane Mailbox with configurable security.

- **Features**
  - Configurable ISM (security module) and custom hook
  - Gas payment quoting and metadata via `StandardHookMetadata`
  - Transparent attestations for received payload hashes

- **Key methods**
  - `handle(uint32 origin, bytes32 sender, bytes message)`: Only mailbox can call; records attestations.
  - `submit(...) payable`: Two overloads to dispatch with default/custom hook; requires `IAttester(source).hasAttested`.
  - `quoteGasPayment(...) view`: Returns required gas payment for a dispatch.

- **Configuration**
  - Constructor wires `mailbox`, `customHook`, and `ism`.
  - Uses Hyperlane domain IDs directly.

---

### Polymer Oracle

Locations:

- Core: `src/integrations/oracles/polymer/PolymerOracle.sol`
- With chain mapping: `src/integrations/oracles/polymer/PolymerOracleMapped.sol`

Proof-of-event validation using Polymer’s CrossL2 prover. No cross-chain message is sent; the oracle reconstructs the payload from the `OutputSettlerBase.OutputFilled` event proven on the destination chain.

- **Features**
  - Message-less, event-based verification
  - Batch proof processing (`receiveMessage(bytes[] proofs)`)
  - Optional chain mapping via `PolymerOracleMapped` (extends `ChainMap`)

- **Key methods**
  - `receiveMessage(bytes proof)`: Verifies event proof (via `ICrossL2ProverV2`), checks event signature, derives payload hash, records attestation.
  - `receiveMessage(bytes[] proofs)`: Batch variant.

- **Configuration**
  - Provide `ICrossL2ProverV2` address in constructor.
  - Use `PolymerOracleMapped` if Polymer domain IDs differ from canonical chain IDs.

---

### Quick comparison

- **Wormhole**: Guardian-verified VAAs, fee via `messageFee()`, requires chain ID mapping.
- **Hyperlane**: ISM-based security, flexible hooks, gas quoting, domain IDs used directly.
- **Polymer**: No cross-chain messages; validates L2 event proofs via prover; optional chain ID mapping.

## Testing

OIF includes comprehensive tests for all core contracts.

### Test Structure

```
test/
├── exploit/            # Test exploit cases
├── input/              # InputSettler tests
├── output/             # OutputSettler tests
├── oracle/             # Oracle implementation tests
├── libs/               # Library tests
├── integration/        # End-to-end integration tests
└── mocks/              # Mock contracts for testing
```

### Running Tests

```bash
# All tests
forge test

# Specific contract
forge test --match-contract InputSettlerTest

# Specific test
forge test --match-test test_fill

# With verbosity
forge test -vvv
```

### Mock Contracts

**Location**: `test/mocks/`

Useful mock implementations for testing:

- `AlwaysYesOracle.sol`: Simple oracle for testing
- `MockERC20.sol`: ERC20 Test token
- `MockCallbackExecutor.sol`: Simplified OutputSettler

## Security Best Practices

### For Developers

1. **Validate All Inputs**: Never trust user-provided data
2. **Check Oracle Attestations**: Always verify before releasing assets
3. **Handle Reentrancy**: Use checks-effects-interactions pattern
4. **Test Edge Cases**: Cover expiry, cancellation, partial fills
5. **Audit External Calls**: Be cautious with callback data

### For Integrators

1. **Use Latest Audited Versions**: Stay updated with security patches
2. **Test Thoroughly**: Run comprehensive integration tests
3. **Monitor Events**: Watch for unexpected behavior
4. **Set Reasonable Timeouts**: Balance UX with security
5. **Handle Failures Gracefully**: Implement refund mechanisms

## Upgradeability

OIF contracts are designed to be:

- **Immutable Core**: Core logic is fixed for security
- **Modular Extensions**: Add new features via separate contracts
- **Composable**: New Settlers work with existing infrastructure

### Adding New Settlers

To add a new InputSettler or OutputSettler:

1. Implement required interfaces
2. Ensure compatibility with existing oracles
3. Use standard encoding formats
4. Test with existing solvers
5. Deploy independently

## Next Steps

- **Deploy Contracts**: Follow the [Deployment Guide](/docs/smart-contracts/deployment)
- **Integrate with Solvers**: See [Solver Documentation](/docs/solvers)
- **Build Custom Settlers**: Review interface requirements and examples
- **Explore Examples**: Check contract examples in `examples/` directory

## Additional Resources

- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts/)
- [Foundry Book](https://book.getfoundry.sh/)
- [EIP-7683 Specification](https://eips.ethereum.org/EIPS/eip-7683)
- [Solidity Documentation](https://docs.soliditylang.org/)
