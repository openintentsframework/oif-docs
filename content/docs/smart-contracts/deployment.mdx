---
title: Deployment
description: What “deployment” means for OIF smart contracts and how to ship safely
---

# Deployment Guide

This page explains what a production deployment entails, who is responsible for each step, and what must be true before/after a release.

<Callout type="warn">
  **Security Warning**: This project currently uses an unaudited version of
  OpenZeppelin Contracts. Before any production release, update to the latest
  audited version.
</Callout>

## Who should read this

- Product/Program, Security, DevOps/SRE, and Smart‑Contract Leads coordinating a release.
- Engineers should use the technical runbook in `oif-contracts` (see Links).

## Scope

This page covers:

- Environments and sequencing (testnet → mainnet)
- Responsibilities and sign‑off
- Required artifacts and records
- Post‑deploy validation, monitoring, and incident readiness

## Release flow (high‑level)

1. Validate on testnet(s) with the same parameters planned for mainnet.
2. Deploy output-side components first, then oracle/config, then input-side components.
3. Verify contracts and record final addresses.
4. Run functional checks and monitoring smoke tests.
5. Announce availability and update integrator docs.

## Responsibilities

- Product/Program: scope, timeline, freeze window, change log.
- Security: audit status, risk review, emergency procedures.
- Contracts Eng: deploy execution, verification, on‑chain configs.
- DevOps/SRE: monitoring, alerting, on-call, incident runbook.
- Integrations: downstream notifications and testing.

## Pre‑deployment checklist

- [ ] Audit status: latest audited OZ and internal contracts
- [ ] Testnet results: pass criteria met (functional + invariants)
- [ ] Parameter freeze: chain IDs, roles, trusted remotes, limits
- [ ] Wallets and signers prepared (multi‑sig where applicable)
- [ ] Monitoring + alerting configured and tested
- [ ] Backout/rollback plan documented
- [ ] Deployment window approved and communicated
- [ ] Ownership/roles and access reviews completed

## Minimal deployment strategy

- Deploy destination/output components first so dependencies exist.
- Configure oracle/trusted remotes.
- Deploy input/entry components last referencing existing dependencies.
- Prefer deterministic addresses (CREATE2) only if required; document salts and rationale.
- Avoid privileged EOAs; use multi‑sig for admin.

## Required artifacts

Maintain a deployment record per network containing:

- Network name, chain ID, timestamp, transaction hashes
- Deployer identity (multi‑sig or role account)
- Contract names, addresses, constructor params
- Verification status and compiler settings
- Config values (oracle type, trusted remotes, rate limits)
- Links to PRs, audits, and monitoring dashboards

## Post‑deployment validation

- Code verified on explorer
- Ownership/roles correct (multi‑sig where applicable)
- Basic read-only calls succeed
- Cross‑component integration checks pass (oracle attestations, settlement path)
- Event emissions observable in monitoring
- Alarms fire on synthetic failure scenarios (optional but recommended)

## Monitoring and alerting expectations

- Health checks for critical components (oracle live, balances above thresholds)
- Alerts for failed tx spikes, unusual volume, downtime, settlement delays

## Useful Links

- **Contracts Repository**: Use the [oif-contracts repository](https://github.com/openintentsframework/oif-contracts)
- **Foundry**: Follow the [Foundry deployment docs](https://book.getfoundry.sh/forge/deploying)

## Related docs

- **Core Contracts**: Read the [Core Contracts](/docs/smart-contracts/core-contracts)
- **Quickstart**: Follow the [Smart Contracts Quickstart](/docs/smart-contracts/quickstart)
- **Solvers**: See the [Solvers Overview](/docs/solvers/overview)
