---
title: Architecture Guide
description: This document provides a comprehensive overview of the OIF Solver's architecture, design principles, and how the different components work together to enable cross-chain intent execution.
---

## Design Principles

### Modular Architecture

The OIF Solver is built as a collection of loosely-coupled, specialized components. Each component has a single responsibility and communicates with others through well-defined interfaces. This approach provides:

- **Maintainability**: Individual components can be developed, tested, and debugged in isolation
- **Extensibility**: New implementations can be added without modifying existing code
- **Testability**: Each component can be unit tested with mocked dependencies

### Event-Driven Design

All components communicate through a centralized event system, enabling:

- **Asynchronous Processing**: Components don't block each other
- **Loose Coupling**: Components only need to know about events, not other components
- **Scalability**: Easy to add new event handlers and processors
- **Observability**: All interactions are captured as events for monitoring

### Multi-Chain Native

Built from the ground up for cross-chain operations:

- **Concurrent Monitoring**: Simultaneously monitor multiple blockchain networks
- **Unified Interface**: Consistent API regardless of the underlying blockchain
- **Extensible**: Easy to add support for new blockchain networks

## High-Level Architecture

```mermaid
graph LR
    subgraph "Input"
        API[REST API]
        Events[On-Chain Events]
    end

    Discovery[Discovery Service]
    Core[Core Engine]
    
    subgraph "Services"
        Order[Order Service]
        Delivery[Delivery Service]
        Settlement[Settlement Service]
        Pricing[Pricing Service]
    end
    
    Storage[Storage & Config]
    
    subgraph "Blockchains"
        Origin[Origin Chain]
        Dest[Destination Chain]
    end

    API --> Discovery
    Events --> Discovery
    Discovery --> Core
    Core --> Order
    Core --> Delivery
    Core --> Settlement
    Core --> Pricing
    
    Order -.-> Storage
    Delivery -.-> Storage
    Settlement -.-> Storage
    Pricing -.-> Storage
    
    Delivery ==> Origin
    Delivery ==> Dest
    Settlement ==> Origin
    Settlement ==> Dest
```

## Component Architecture

### Core Engine (solver-core)

The orchestration layer that coordinates all other components.

**Responsibilities:**

- Event-driven workflow orchestration
- Order state management and transitions
- Component lifecycle management
- Error handling and recovery
- Graceful shutdown coordination

**Event Flow:**

1. Receives events from discovery services
2. Routes events to appropriate handlers
3. Manages order state transitions
4. Coordinates multi-step operations

### Discovery Layer (solver-discovery)

Monitors various sources for new cross-chain intents.

**Discovery Sources:**

- **On-Chain Discovery**: Monitors blockchain events for intent submissions
- **Off-Chain Discovery**: Receives intents via REST API endpoints
- **Future Sources**: Extensible to support new discovery mechanisms

### Service Layer

#### Order Service (solver-order)

Handles intent validation, execution strategy evaluation, and transaction generation.

**Order Lifecycle:**

1. **Validation**: Parse and validate intent data
2. **Strategy Evaluation**: Determine optimal execution timing
3. **Transaction Generation**: Create blockchain transactions
4. **State Updates**: Track order progress

#### Delivery Service (solver-delivery)

Manages reliable transaction submission (alloy-implementation) and monitoring across multiple blockchain networks.

**Features:**

- Multi-chain transaction submission
- Confirmation monitoring with configurable depth
- Gas estimation and pricing
- Transaction status tracking

#### Settlement Service (solver-settlement)

Handles post-execution settlement verification and claim processing.

**Settlement Flow:**

1. **Fill Validation**: Verify transaction execution and extract proofs
2. **Dispute Period Monitoring**: Wait for required settlement windows
3. **Claim Generation**: Create claim transactions when ready
4. **Oracle Verification**: Validate cross-chain proofs

### Infrastructure Layer

#### Storage Service (solver-storage)

Provides persistent state management with TTL support.

**Features:**

- Configurable TTL for different data types
- Automatic cleanup of expired data
- Multiple backend implementations (file, future: database)

#### Account Service (solver-account)

Manages cryptographic keys and signing on-chain operations.

**Security Features:**

- Secure key storage and handling
- Multiple account support
- Per-network account mapping

#### Config Service (solver-config)

Provides centralized configuration management with validation and environment variable support.

**Features:**

- TOML-based configuration files
- Environment variable substitution with defaults
- Modular configuration via file includes
- Comprehensive validation of all settings
- Support for network, account, storage, and service configurations

#### Pricing Service (solver-pricing)

Manages asset pricing and currency conversions for profitability calculations.

**Features:**

- Pluggable pricing oracle implementations
- Wei to fiat currency conversions
- Configurable commission and buffer rates
- Trading pair support and validation

#### Type System (solver-types)

Provides shared type definitions and utilities used across all solver components.

**Key Types:**

- **Events**: Inter-service communication structures
- **Orders**: Intent and order data models
- **Networks**: Chain configuration and token definitions
- **Storage**: Persistence layer interfaces
- **Discovery**: Intent source types
- **Standards**: Protocol-specific types (EIP-7683, EIP-7930)
- **Validation**: Configuration schema traits

#### Application Service (solver-service)

Complete solver application that integrates all components into a runnable service.

**Features:**

- HTTP REST API for quote generation and intent submission
- Authentication and authorization middleware
- EIP-712 signature validation
- Rate limiting and CORS support
- Concurrent solver engine and API server execution
- Factory-based component initialization from configuration

## Data Flow Architecture

### Intent Discovery Flow

```mermaid
sequenceDiagram
    participant External as External Source
    participant Discovery as Discovery Service
    participant Core as Core Engine
    participant Storage as Storage Service

    External->>Discovery: New Intent Event
    Discovery->>Discovery: Validate Intent Format
    Discovery->>Core: IntentDiscovered Event
    Core->>Storage: Store Intent
    Core->>Core: Queue for Processing
```

### Order Processing Flow

```mermaid
sequenceDiagram
    participant Core as Core Engine
    participant Order as Order Service
    participant Delivery as Delivery Service
    participant Settlement as Settlement Service
    participant Storage as Storage Service

    Note over Core,Storage: Intent Processing
    Core->>Order: Validate Intent
    Order->>Core: Validated Order
    Core->>Storage: Store Order

    Note over Core,Storage: Execution Decision
    Core->>Order: Should Execute?
    Order->>Core: Execution Decision
    Core->>Order: Generate Fill Transaction
    Order->>Core: Fill Transaction Ready

    Note over Core,Storage: Transaction Delivery
    Core->>Delivery: Submit Transaction
    Delivery->>Core: Transaction Submitted
    Core->>Storage: Update Order Status

    Note over Core,Storage: Settlement Processing
    Delivery->>Core: Transaction Confirmed
    Core->>Settlement: Validate Fill
    Settlement->>Core: Fill Validated
    Core->>Storage: Store Fill Proof

    Note over Core,Storage: Claim Processing
    Settlement->>Core: Claim Ready
    Core->>Order: Generate Claim Transaction
    Order->>Core: Claim Transaction Ready
    Core->>Delivery: Submit Claim
    Delivery->>Core: Claim Confirmed
    Core->>Storage: Mark Order Complete
```

## State Management

### Order State Machine

Orders progress through defined states with clear transitions:

```mermaid
stateDiagram-v2
    [*] --> Created: Order Created
    Created --> Pending: Prepare Transaction
    Created --> Executing: Direct Execution
    Pending --> Executing: Prepare Confirmed
    Executing --> Executed: Fill Confirmed
    Executed --> PostFilled: Post-Fill Required
    Executed --> Settled: Ready for Settlement
    PostFilled --> Settled: Post-Fill Complete
    Settled --> PreClaimed: Pre-Claim Required
    Settled --> Finalized: Claim Confirmed
    PreClaimed --> Finalized: Claim Confirmed
    Finalized --> [*]

    Created --> Failed: Prepare Failed
    Pending --> Failed: Execution Failed
    Executing --> Failed: Fill Failed
    Executed --> Failed: Post-Fill Failed
    PostFilled --> Failed: Settlement Failed
    Settled --> Failed: Claim Failed
    PreClaimed --> Failed: Finalization Failed
    Failed --> [*]
```

**State Descriptions:**

- **Created**: Order has been created but not yet prepared for execution
- **Pending**: Prepare transaction has been submitted and is awaiting confirmation
- **Executing**: Order is currently executing (prepare confirmed, fill transaction in progress)
- **Executed**: Fill transaction has been confirmed on the destination chain
- **PostFilled**: Post-fill transaction has been completed (optional state for certain order types)
- **Settled**: Order is ready for claiming rewards on the origin chain
- **PreClaimed**: Pre-claim transaction has been completed (optional state for certain settlement types)
- **Finalized**: Order is fully completed with claim transaction confirmed (terminal state)
- **Failed**: Order execution failed at some stage (terminal state)

## System Boundaries and Integration Points

### External Dependencies

The OIF Solver system relies on several external components and services:

**Blockchain Networks:**

- **RPC Providers**: HTTP/WebSocket endpoints for blockchain interaction
- **Integration**: Configurable per network with failover support
- **Responsibility**: Transaction submission, event monitoring, state queries

**Price Oracles:**

- **CoinGecko API**: Real-time asset pricing data
- **Integration**: HTTP REST API for currency conversions
- **Responsibility**: External to the solver; used for profitability calculations

**Storage Backends:**

- **File System**: Current implementation for persistent state
- **Future**: Database backends (PostgreSQL, Redis)
- **Responsibility**: Order state, transaction receipts, proofs

### System Boundaries

**Inside the Solver:**

- Intent discovery and validation
- Execution strategy evaluation
- Transaction generation and signing
- Cross-chain settlement coordination
- State management and persistence
- Profitability calculations

**Outside the Solver:**

- Intent origination (submitted by users/applications)
- Blockchain consensus and finality
- Asset price discovery
- Oracle proof generation
- Cross-chain message verification

### Integration APIs

**Inbound Interfaces:**

- **REST API**: HTTP endpoints for intent submission and quotes (solver-service)
- **On-Chain Events**: Smart contract event monitoring (solver-discovery)
- **WebSocket**: Real-time event streaming from blockchain networks

**Outbound Interfaces:**

- **JSON-RPC**: Blockchain transaction submission and queries
- **HTTP REST**: Price oracle data fetching
- **File I/O**: Persistent state storage

## Error Handling Strategy

### Layered Error Handling

1. **Component Level**: Each component handles its specific errors
2. **Service Level**: Services aggregate and transform component errors
3. **Core Level**: Core engine handles workflow errors and recovery
4. **Application Level**: Top-level error handling for unrecoverable errors
