# How It Works

The OIF Solver operates through a multi-stage pipeline that handles the complete lifecycle of cross-chain intent execution. This guide explains each stage in detail.

## The Intent Execution Pipeline

The solver processes intents through seven distinct stages:

1. **Intent Discovery** - Monitor blockchain networks for new intents
2. **Quote Generation** - Generate execution quotes via REST API (optional)
3. **Intent Validation** - Parse and validate intent data
4. **Profitability Analysis** - Calculate costs and verify profitability
5. **Execution Strategy** - Determine optimal execution timing
6. **Transaction Execution** - Submit and monitor transactions
7. **Settlement Processing** - Complete cross-chain settlement

## 1. Intent Discovery

The solver monitors configured blockchain networks for new intent events. It can discover intents through multiple channels:

- **On-chain monitoring**: Direct blockchain event monitoring for intents submitted to smart contracts
- **Off-chain APIs**: REST API endpoints for intent submission and quote requests
- **Multiple sources**: Simultaneous monitoring of various discovery channels

The discovery system runs continuously, watching for new `open` on-chain events across all configured chains.

## 2. Quote Generation API

Before executing intents, the solver can generate quotes for users through its REST API. This allows users to preview execution details and costs before committing on-chain.

### Quote Request Flow

1. User submits intent parameters to the solver's REST API
2. Solver calculates execution costs and generates a quote
3. User reviews the quote details (amounts, fees, ETA)
4. User signs the order data using EIP-712
5. User submits the signed order on-chain or back to the solver

### Quote Structure

Each quote contains:

- **Orders**: Complete order data ready for on-chain submission
- **Costs**: Detailed breakdown of gas fees, commissions, and operational expenses
- **ETA**: Estimated time for complete cross-chain execution
- **Validity Period**: Timestamp indicating quote expiration

### Quote Signing (EIP-712)

Before submitting quotes to the solver for execution, users must sign the order data:

- **Signature Standard**: Uses EIP-712 typed structured data signing for human-readable and secure signatures
- **User Responsibility**: Always carefully review what you are signing - verify the token amounts, addresses, chains, and all order parameters
- **Authorization**: The signature authorizes the solver to execute the cross-chain intent on your behalf
- **Security**: Only sign quotes from trusted sources and verify all details before signing

## 3. Intent Validation

Once an intent is discovered (either from on-chain events or quote API), the solver validates it:

1. **Parse Intent Data**: Decode the intent according to the specified protocol (EIP-7683, etc.)
2. **Validate Structure**: Ensure all required fields are present and properly formatted
3. **Check Liquidity**: Verify sufficient liquidity exists for execution
4. **Assess Feasibility**: Confirm the intent can be fulfilled based on current market conditions
5. **Convert to Order**: Transform the validated intent into an executable order

Invalid intents are rejected and logged for monitoring purposes.

## 4. Profitability Analysis

Before accepting any intent, the solver performs a comprehensive profitability analysis to ensure execution will be financially viable.

### Cost Context Calculation

The solver builds a complete cost context that accounts for all operational expenses:

- **Gas Costs**: Estimated fees for all transactions across all chains
- **Price Data**: Real-time token prices for accurate USD conversions
- **Network Conditions**: Current gas prices and congestion levels
- **Swap Calculations**: Token amount calculations based on swap type

### Swap Types and Amount Calculation

The solver supports two types of swaps, each affecting how costs are embedded in quotes:

#### ExactInput

User specifies the exact input amount they want to provide:

- Solver calculates the output amount after deducting all costs
- Costs are subtracted from the user's output amount
- Example: User provides 100 USDC, receives calculated ETH minus fees

#### ExactOutput

User specifies the exact output amount they want to receive:

- Solver calculates the required input amount including all costs
- Costs are added to the required input amount
- Example: User wants 1 ETH, must provide calculated USDC plus fees

### Cost Calculation

The solver calculates all operational costs involved in executing the cross-chain intent:

#### Gas Costs

Estimates gas fees for all required transactions:

- **Open transaction**: On the origin chain to initiate the intent
- **Fill transaction**: On the destination chain to fulfill the user's request (future extension, not yet implemented)
- **Claim transaction**: On the origin chain to complete settlement

#### Additional Costs

- **Gas Buffer**: Adds a configurable buffer (in basis points) to account for gas price volatility
- **Base Price**: Covers any negative spread when output value exceeds input value

### USD Pricing Conversion

All token amounts are converted to USD using real-time pricing data to ensure accurate cross-token comparisons. Note that this only works for token pairs that have pricing information available from configured price sources:

- **Price Sources**: Integration with price oracles and market data providers
- **Cross-Chain Pricing**: Consistent pricing across different blockchain networks
- **Token Normalization**: Proper handling of different decimal precisions
- **Cost Embedding**: Costs are embedded into quote amounts based on swap type

### Profit Margin Calculation

The solver calculates profit margin by comparing the value received versus costs incurred, with all amounts normalized to USD for accurate assessment across different tokens.

### Profitability Validation

Each intent must meet the configured minimum profitability threshold (`min_profitability_pct`) before execution:

- **Threshold Check**: The calculated profit margin must exceed the minimum required percentage
- **Automatic Rejection**: Intents failing profitability validation are automatically skipped
- **Configurable Minimum**: Operators can set their desired minimum profit margin (e.g., 1.0% in demo configurations)

This ensures the solver only executes intents that provide adequate compensation for the operational costs and risks involved.

## 5. Execution Strategy

The solver evaluates when and how to execute orders based on multiple factors:

### Market Conditions

- **Gas Prices**: Wait for favorable gas prices to reduce execution costs
- **Liquidity**: Ensure sufficient liquidity is available at the desired price
- **Timing**: Consider network congestion and optimal execution windows

### Execution Strategies

Configurable logic allows operators to implement custom execution strategies:

- **Immediate Execution**: Execute as soon as profitability is confirmed
- **Gas-Optimized**: Wait for gas prices to fall below a threshold
- **Batch Execution**: Group multiple intents for gas efficiency
- **Custom Logic**: Implement domain-specific execution rules

### Risk Assessment

Before execution, the solver performs final safety checks:

- Verify account balances and approvals
- Confirm transaction parameters are still valid
- Check for any market changes that might affect profitability
- Validate settlement contract state

## 6. Transaction Execution

When the execution strategy determines it's time to execute, the solver handles the complete transaction lifecycle:

### Transaction Generation

- Generate the necessary blockchain transactions (fill, post-fill, etc.)
- Set appropriate gas parameters based on network conditions
- Sign transactions using the configured wallet/signer

### Transaction Submission

- Submit transactions to the appropriate blockchain networks
- Handle nonce management and transaction replacement if needed
- Monitor mempool for transaction status

### Transaction Monitoring

- Track transaction confirmation across multiple blocks
- Handle transaction failures and retries with exponential backoff
- Update internal state based on transaction outcomes
- Log detailed execution metrics for monitoring

### Error Recovery

- Detect failed transactions and determine root cause
- Implement retry logic with configurable parameters
- Revert state and release locked resources on permanent failure
- Alert operators to critical execution issues

## 7. Settlement Processing

After successful execution on the destination chain, the solver completes the cross-chain settlement:

### Fill Validation

- Monitor for fill transaction confirmation
- Extract execution proofs from transaction receipts
- Validate fill amounts match expected values
- Store proof data for claim submission

### Dispute Period Monitoring

- Track settlement contract dispute periods
- Wait for required confirmation blocks
- Monitor for any dispute transactions
- Handle dispute resolution if needed

### Claim Submission

When settlement conditions are met:

- Generate claim transaction with execution proofs
- Submit claim to origin chain settlement contract
- Monitor claim transaction confirmation
- Verify funds are successfully claimed

### Settlement Completion

- Update intent status to completed
- Record final profit/loss metrics
- Release any locked resources
- Archive execution data for analysis

## Authorization Mechanisms

The solver supports multiple authorization mechanisms for different settlement patterns:

### Permit2

Token approval mechanism used for escrow-based settlement patterns:

- Enables gasless token approvals through signature-based permissions
- Users sign approval messages instead of on-chain transactions
- Reduces gas costs and improves user experience

### TheCompact

Resource lock mechanism for compact settlement:

- Allows users to allocate tokens for specific purposes without transferring custody
- Supports more complex settlement patterns
- Enables capital-efficient cross-chain operations

### EIP-3009

Transfer authorization standard for gasless transfers:

- Enables transfers via signed messages
- Reduces user transaction costs
- Compatible with USDC and other major tokens

## Next Steps

- **[Architecture Overview](architecture.md)**: Deep dive into the solver's technical architecture
- **[Configuration Guide](configuration.md)**: Configure profitability thresholds, execution strategies, and more
- **[API Reference](api.md)**: Complete API documentation for the quote system
